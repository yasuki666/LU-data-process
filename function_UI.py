# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'LU信号处理.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import sys
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QAction, QMainWindow, QFileDialog, QTextEdit, QMessageBox
from PyQt5.QtWidgets import QApplication

import pyqtgraph as pg

import pandas as pd
import numpy as np
from scipy import signal
from pywt import wavedec
import pywt

import wavelet_functions
import original_UI


class Ui_MainWindow(original_UI.Ui_MainWindow):

    def new_set_UI(self, mainWindow):
        self.setupUi(mainWindow)

        # 菜单栏 File
        # open new file
        self.actionopen_new_file.triggered.connect(self.open_file)

        # 菜单栏 Save
        self.actionsave_single_column.triggered.connect(self.save_single_column)

        # 控制区模块 初始化
        self.column_number_value.setText('1')  # 默认列数为1
        self.sampling_rate_value.setText('2500')  # 默认采样率为2500MHz
        self.start_sampling_time_value.setText('1')  # 默认开始采样时间为1us
        self.end_sampling_time_value.setText('5')  # 默认结束采样时间为5us

        # 按钮 导入数据
        self.import_data_button.clicked.connect(self.import_data)

        # 按钮 快捷更改文件
        self.next_file_button.clicked.connect(self.next_file)

        # 按钮 数据列数改变 ← →
        self.last_column_button.clicked.connect(self.column_number_minus)
        self.next_column_button.clicked.connect(self.column_number_plus)

        # 必须先将四个画布建立好
        pg.setConfigOption('background', 'w')  # 背景色改为白色
        pg.setConfigOption('foreground', 'k')  # 前景色改为黑色
        self.original_time_canvas = pg.PlotWidget(self.Original_time)  # 创建一个绘图控件
        self.original_time_canvas.resize(300, 160)
        self.original_time_canvas_plot = self.original_time_canvas.plot()
        self.original_frequency_canvas = pg.PlotWidget(self.Original_frequency)
        self.original_frequency_canvas.resize(300, 160)
        self.original_frequency_canvas_plot = self.original_frequency_canvas.plot()
        self.processed_time_canvas = pg.PlotWidget(self.processed_time)
        self.processed_time_canvas.resize(300, 160)
        self.processed_time_canvas_plot = self.processed_time_canvas.plot()
        self.processed_frequency_canvas = pg.PlotWidget(self.processed_frequency)
        self.processed_frequency_canvas.resize(300, 160)
        self.processed_frequency_canvas_plot = self.processed_frequency_canvas.plot()

        # 按钮 作图
        self.drawing_button.clicked.connect(self.original_data_time_frequency_drawing)

        # box 低通滤波
        self.passbond_boundary_frequency_value.setText('12.24')
        self.stopband_boundary_frequency_value.setText('25')
        self.lowpass_filter_button.clicked.connect(self.lowpass_filter)

        # box 带通滤波
        self.passbond_lowerlimit_frequency_value.setText('5.3')
        self.passbond_upperlimit_frequency_value.setText('12.24')
        self.stopbond_lowerlimit_frequency_value.setText('3')
        self.stopbond_upperlimit_frequency_value.setText('25')
        self.bandpass_filter_button.clicked.connect(self.bandpass_filter)

        # box 小波滤波
        self.decomposition_layer_value.setText('8')
        self.wavelet_type_value.setText('db3')
        self.wavelet_filter_button.clicked.connect(self.wavelet_filter)

    # 函数 打开文件对话窗 将路径保存至文件路径栏
    def open_file(self):
        # 注意，这里参数必须传入self.centralwidget，因为QFileDialog只接受widget参数
        self.file_name_list = QFileDialog.getOpenFileNames(self.centralwidget, '选择文件', '', 'Excel files(*.xlsx , *.xls , *.csv)')
        self.file_index = 0
        self.file_path_value.setText(self.file_name_list[0][self.file_index])

    # 函数 按文件路径栏已储存的路径将文件数据导入
    def import_data(self):
        try:
            self.file_data = pd.read_excel(self.file_path_value.text())
            self.file_data = np.array(self.file_data)
            QMessageBox.information(self.centralwidget, '提示', '数据导入成功')
        except:
            QMessageBox.information(self.centralwidget, '提示', '文件路径有误')

    # 函数 快捷更改文件路径
    def next_file(self):
        '''
        ex: /totaldata_20210628_50mj.xls' -> /totaldata_20210628_60mj.xls'

        file_path = self.file_path_value.text()
        i = 0
        while file_path[i] != '.':
            i -= 1

        num = int(file_path[i - 4])
        num += 1
        file_path = file_path[:i - 4] + str(num) + file_path[i - 3:]
        self.file_path_value.setText(file_path)'''
        try:
            self.file_index += 1
            self.file_path_value.setText(self.file_name_list[0][self.file_index])
        except:
            QMessageBox.information(self.centralwidget, '提示', '文件路径列表已到底')

    # 函数 数据列数减1
    def column_number_minus(self):
        num = int(self.column_number_value.text())
        # 判断是否越栈
        if num > 1:
            num -= 1
        self.column_number_value.setText(str(num))

    # 函数 数据列数加1
    def column_number_plus(self):
        num = int(self.column_number_value.text())
        self.column_total_number = self.file_data.shape[1]
        num += 1
        # 判断是否越栈
        if num >= self.column_total_number:
            num -= 1
            QMessageBox.information(self.centralwidget, '提示', '已到达最后一列')
        self.column_number_value.setText(str(num))

    # 函数 画图 将原始数据时域图与频域图画出
    def original_data_time_frequency_drawing(self):
        try:
            # 原始数据时域图
            self.column_num = int(self.column_number_value.text())
            self.time_aix = self.file_data[:, 0]
            self.time_aix = self.time_aix * 1000000
            self.original_time_amplitude_aix = self.file_data[:, self.column_num]
            try:
                i, j = 0, 0
                while (self.time_aix[i] < int(self.start_sampling_time_value.text())):
                    i += 1
                while (self.time_aix[j] < int(self.end_sampling_time_value.text())):
                    j += 1
                self.time_aix = self.time_aix[i:j]

                self.original_time_amplitude_aix = self.original_time_amplitude_aix[i:j]
                self.original_time_canvas_plot.setData(self.time_aix, self.original_time_amplitude_aix,
                                                       pen='b')  # pen参数改变线条颜色，symbol改变点形状，symbolColor改变点颜色
            except:
                QMessageBox.information(self.centralwidget, '提示', '采样时间设置有误')

            # 原始数据频域图
            temprory_time_amplitude_aix = self.original_time_amplitude_aix - np.mean(
                self.original_time_amplitude_aix)  # 消去直流分量，更能体现频谱信息
            self.original_frequency_amplitude_aix = np.fft.fft(temprory_time_amplitude_aix)  # 快速傅里叶变换
            self.original_frequency_amplitude_aix = abs(self.original_frequency_amplitude_aix)  # 转换到实数域
            n = len(self.original_time_amplitude_aix)
            self.frequency_aix = []
            self.sampling_rate = int(self.sampling_rate_value.text())
            # 得到频域横坐标
            for i in range(n):
                self.frequency_aix.append(i * self.sampling_rate / n)
            self.frequency_aix = self.frequency_aix[:int(n / 2)]
            self.original_frequency_amplitude_aix = self.original_frequency_amplitude_aix[:int(n / 2)]
            # 为了方便观看只展示前边0-100MHz部分
            self.showing_frequency_aix = self.frequency_aix[:int(n * 100 / (self.sampling_rate))]
            self.showing_original_frequency_amplitude_aix = self.original_frequency_amplitude_aix[
                                                            :int(n * 100 / (self.sampling_rate))]
            self.original_frequency_canvas_plot.setData(self.showing_frequency_aix,
                                                        self.showing_original_frequency_amplitude_aix, pen='b')
        except:
            QMessageBox.information(self.centralwidget, '提示', '未导入数据或数据有误')

    # 函数 低通滤波
    def lowpass_filter(self):
        try:
            self.original_data_time_frequency_drawing()
            frequency_pass = float(self.passbond_boundary_frequency_value.text()) * 1000000
            frequency_stop = float(self.stopband_boundary_frequency_value.text()) * 1000000
            normalized_frequency_pass = frequency_pass / (self.sampling_rate * 1000000 / 2)  # 归一化
            normalized_frequency_stop = frequency_stop / (self.sampling_rate * 1000000 / 2)
            max_passband_loss = 1  # 通带最大衰减 ，默认为1dB
            min_stopband_attenuation = 20  # 阻带最小衰减，默认为20dB

            # filter_order为巴特沃斯滤波器阶数，butterworth_natrual_frequency为3dB截止频率
            filter_order, butterworth_natrual_frequency = signal.buttord(normalized_frequency_pass,
                                                                         normalized_frequency_stop,
                                                                         max_passband_loss,
                                                                         min_stopband_attenuation)
            b, a = signal.butter(filter_order, butterworth_natrual_frequency, 'lowpass')
            self.processed_time_amplitude_aix = signal.filtfilt(b, a, self.original_time_amplitude_aix)
            self.processed_time_canvas_plot.setData(self.time_aix, self.processed_time_amplitude_aix, pen='b')

            # 转换至频域
            temprory_time_amplitude_aix = self.processed_time_amplitude_aix - np.mean(
                self.processed_time_amplitude_aix)  # 消去直流分量，更能体现频谱信息
            self.processed_frequency_amplitude_aix = np.fft.fft(temprory_time_amplitude_aix)  # 快速傅里叶变换
            self.processed_frequency_amplitude_aix = abs(self.processed_frequency_amplitude_aix)  # 转换到实数域

            n = len(self.processed_time_amplitude_aix)
            self.sampling_rate = int(self.sampling_rate_value.text())
            self.processed_frequency_amplitude_aix = self.processed_frequency_amplitude_aix[:int(n / 2)]
            # 为了方便观看只展示前边0-100MHz部分
            self.showing_processed_frequency_amplitude_aix = self.processed_frequency_amplitude_aix[
                                                             :int(n * 100 / (self.sampling_rate))]
            self.processed_frequency_canvas_plot.setData(self.showing_frequency_aix,
                                                         self.showing_processed_frequency_amplitude_aix, pen='b')

            self.original_data_max = max(self.original_time_amplitude_aix)
            self.original_data_min = min(self.original_time_amplitude_aix)
            self.original_data_peaktopeak = self.original_data_max - self.original_data_min
            self.original_data_max = round(self.original_data_max, 6)
            self.original_data_min = round(self.original_data_min, 6)
            self.original_data_peaktopeak = round(self.original_data_peaktopeak, 6)
            self.processed_data_max = max(self.processed_time_amplitude_aix)
            self.processed_data_min = min(self.processed_time_amplitude_aix)
            self.processed_data_peaktopeak = self.processed_data_max - self.processed_data_min
            self.processed_data_max = round(self.processed_data_max, 6)
            self.processed_data_min = round(self.processed_data_min, 6)
            self.processed_data_peaktopeak = round(self.processed_data_peaktopeak, 6)
            self.original_data_maximum_value.setText(str(self.original_data_max))
            self.original_data_minimum_value.setText(str(self.original_data_min))
            self.original_data_peaktopeak_value.setText(str(self.original_data_peaktopeak))
            self.processed_data_maximum_value.setText(str(self.processed_data_max))
            self.processed_data_minimum_value.setText(str(self.processed_data_min))
            self.processed_data_peaktopeak_value.setText(str(self.processed_data_peaktopeak))
        except:
            QMessageBox.information(self.centralwidget, '提示', '滤波失败，请检查滤波参数！')

    # 函数 带通滤波
    def bandpass_filter(self):
        try:
            self.original_data_time_frequency_drawing()
            # 首先设计巴特沃斯滤波器
            frequency_pass_low = float(self.passbond_lowerlimit_frequency_value.text()) * 1000000
            frequency_pass_high = float(self.passbond_upperlimit_frequency_value.text()) * 1000000
            frequency_stop_low = float(self.stopbond_lowerlimit_frequency_value.text()) * 1000000
            frequency_stop_high = float(self.stopbond_upperlimit_frequency_value.text()) * 1000000
            passband_array = np.array([frequency_pass_low, frequency_pass_high])
            stopband_array = np.array([frequency_stop_low, frequency_stop_high])
            normalized_passband_array = passband_array / (self.sampling_rate * 1000000 / 2)  # 归一化
            normalized_stopband_array = stopband_array / (self.sampling_rate * 1000000 / 2)
            max_passband_loss = 1  # 通带最大衰减 ，默认为1dB
            min_stopband_attenuation = 20  # 阻带最小衰减，默认为20dB

            # filter_order为巴特沃斯滤波器阶数，butterworth_natrual_frequency为3dB截止频率
            filter_order, butterworth_natrual_frequency = signal.buttord(normalized_passband_array,
                                                                         normalized_stopband_array,
                                                                         max_passband_loss,
                                                                         min_stopband_attenuation)
            b, a = signal.butter(filter_order, butterworth_natrual_frequency, 'bandpass')  # b,a分别为滤波多项式的分子(b)和分母(a)
            self.processed_time_amplitude_aix = signal.filtfilt(b, a, self.original_time_amplitude_aix)
            self.processed_time_canvas_plot.setData(self.time_aix, self.processed_time_amplitude_aix, pen='b')

            # 变换频域
            temprory_time_amplitude_aix = self.processed_time_amplitude_aix - np.mean(
                self.processed_time_amplitude_aix)  # 消去直流分量，更能体现频谱信息
            self.processed_frequency_amplitude_aix = np.fft.fft(temprory_time_amplitude_aix)  # 快速傅里叶变换
            self.processed_frequency_amplitude_aix = abs(self.processed_frequency_amplitude_aix)  # 转换到实数域
            n = len(self.processed_time_amplitude_aix)
            self.sampling_rate = int(self.sampling_rate_value.text())
            self.processed_frequency_amplitude_aix = self.processed_frequency_amplitude_aix[:int(n / 2)]
            # 为了方便观看只展示前边0-100MHz部分
            self.showing_processed_frequency_amplitude_aix = self.processed_frequency_amplitude_aix[
                                                             :int(n * 100 / (self.sampling_rate))]
            self.processed_frequency_canvas_plot.setData(self.showing_frequency_aix,
                                                         self.showing_processed_frequency_amplitude_aix, pen='b')

            self.original_data_max = max(self.original_time_amplitude_aix)
            self.original_data_min = min(self.original_time_amplitude_aix)
            self.original_data_peaktopeak = self.original_data_max - self.original_data_min
            self.original_data_max = round(self.original_data_max, 6)
            self.original_data_min = round(self.original_data_min, 6)
            self.original_data_peaktopeak = round(self.original_data_peaktopeak, 6)
            self.processed_data_max = max(self.processed_time_amplitude_aix)
            self.processed_data_min = min(self.processed_time_amplitude_aix)
            self.processed_data_peaktopeak = self.processed_data_max - self.processed_data_min
            self.processed_data_max = round(self.processed_data_max, 6)
            self.processed_data_min = round(self.processed_data_min, 6)
            self.processed_data_peaktopeak = round(self.processed_data_peaktopeak, 6)
            self.original_data_maximum_value.setText(str(self.original_data_max))
            self.original_data_minimum_value.setText(str(self.original_data_min))
            self.original_data_peaktopeak_value.setText(str(self.original_data_peaktopeak))
            self.processed_data_maximum_value.setText(str(self.processed_data_max))
            self.processed_data_minimum_value.setText(str(self.processed_data_min))
            self.processed_data_peaktopeak_value.setText(str(self.processed_data_peaktopeak))
        except:
            QMessageBox.information(self.centralwidget, '提示', '滤波失败，请检查滤波参数！')

    # 函数 小波滤波
    def wavelet_filter(self):
        try:
            self.original_data_time_frequency_drawing()
            # 调用已编写好的wavelet_functions.py的接口
            wavelet_single_demensional_denoising_function_dictionary = {
                'rigrsure': wavelet_functions.wavelet_single_demensional_denoising_rigrsure,
                'sqtwolog': wavelet_functions.wavelet_single_demensional_denoising_sqtwolog,
                'minimaxi': wavelet_functions.wavelet_single_demensional_denoising_minimaxi,
                'heursure': wavelet_functions.wavelet_single_demensional_denoising_heursure}

            def wavelet_single_demensional_denoising(data, threshold_type, threshold_usage, noise_estimating_method,
                                                     wavelet_type, decomposition_layer_number):
                return wavelet_single_demensional_denoising_function_dictionary.get(threshold_type)(data,
                                                                                                    threshold_usage,
                                                                                                    noise_estimating_method,
                                                                                                    wavelet_type,
                                                                                                    decomposition_layer_number)

            data = self.original_time_amplitude_aix
            threshold_usage = self.threshold_process_method_value.currentText()
            noise_estimating_method = self.threshold_function_select_method_value.currentText()
            wavelet_type = self.wavelet_type_value.text()
            decomposition_layer_number = int(self.decomposition_layer_value.text())
            threshold_type = self.threshold_select_criteria_value.currentText()
            self.processed_time_amplitude_aix = wavelet_single_demensional_denoising(data,
                                                                                     threshold_type=threshold_type,
                                                                                     threshold_usage=threshold_usage,
                                                                                     noise_estimating_method=noise_estimating_method,
                                                                                     wavelet_type=wavelet_type,
                                                                                     decomposition_layer_number=decomposition_layer_number)
            self.processed_time_canvas_plot.setData(self.time_aix, self.processed_time_amplitude_aix, pen='b')

            # 变换频域
            temprory_time_amplitude_aix = self.processed_time_amplitude_aix - np.mean(
                self.processed_time_amplitude_aix)  # 消去直流分量，更能体现频谱信息
            self.processed_frequency_amplitude_aix = np.fft.fft(temprory_time_amplitude_aix)  # 快速傅里叶变换
            self.processed_frequency_amplitude_aix = abs(self.processed_frequency_amplitude_aix)  # 转换到实数域
            n = len(self.processed_time_amplitude_aix)
            self.sampling_rate = int(self.sampling_rate_value.text())
            self.processed_frequency_amplitude_aix = self.processed_frequency_amplitude_aix[:int(n / 2)]
            # 为了方便观看只展示前边0-100MHz部分
            self.showing_processed_frequency_amplitude_aix = self.processed_frequency_amplitude_aix[
                                                             :int(n * 100 / (self.sampling_rate))]
            self.processed_frequency_canvas_plot.setData(self.showing_frequency_aix,
                                                         self.showing_processed_frequency_amplitude_aix, pen='b')

            self.original_data_max = max(self.original_time_amplitude_aix)
            self.original_data_min = min(self.original_time_amplitude_aix)
            self.original_data_peaktopeak = self.original_data_max - self.original_data_min
            self.original_data_max = round(self.original_data_max, 6)
            self.original_data_min = round(self.original_data_min, 6)
            self.original_data_peaktopeak = round(self.original_data_peaktopeak, 6)
            self.processed_data_max = max(self.processed_time_amplitude_aix)
            self.processed_data_min = min(self.processed_time_amplitude_aix)
            self.processed_data_peaktopeak = self.processed_data_max - self.processed_data_min
            self.processed_data_max = round(self.processed_data_max, 6)
            self.processed_data_min = round(self.processed_data_min, 6)
            self.processed_data_peaktopeak = round(self.processed_data_peaktopeak, 6)
            self.original_data_maximum_value.setText(str(self.original_data_max))
            self.original_data_minimum_value.setText(str(self.original_data_min))
            self.original_data_peaktopeak_value.setText(str(self.original_data_peaktopeak))
            self.processed_data_maximum_value.setText(str(self.processed_data_max))
            self.processed_data_minimum_value.setText(str(self.processed_data_min))
            self.processed_data_peaktopeak_value.setText(str(self.processed_data_peaktopeak))
        except:
            QMessageBox.information(self.centralwidget, '提示', '滤波失败，请检查滤波参数！')

    # 函数 保存单列数据
    def save_single_column(self):
        save_file_name = self.file_name_list[self.file_index][0]
        i,j = 0,0
        while save_file_name[i] != '/':
            i -= 1
        while save_file_name[j] != '.':
            j -= 1
        save_file_name = save_file_name[i:j] + '_processed'
        save_file_path = QFileDialog.getSaveFileName(self.centralwidget,'选择保存位置', save_file_name, 'Excel files(*.xlsx , *.xls , *.csv)')
        print(save_file_path[0])